"""
Strategy Engine — Hybrid MNQ 5-Minute Strategies
Blends QuantVue momentum + Vector Algorithmics market-neutral volatility logic.

Hybrid 1: Momentum-Volatility Fusion
  - 9/21 EMA crossover for momentum signal
  - 50 EMA trend filter for directional bias
  - Volume confirmation (above 1.2× 20-period SMA)
  - ATR breakout confirmation (Vector-style)
  
Hybrid 2: 5m MNQ ORB/Pullback
  - Opening Range Breakout (first 15 min of RTH)
  - EMA pullback entries in trend direction
  - Hard stops 20-30 points, 1.5-2R targets
  - RTH session filter, max trades cap
"""

import pandas as pd
import numpy as np
from dataclasses import dataclass
from typing import Optional, List, Dict, Tuple
from enum import Enum


class Signal(Enum):
    LONG = "LONG"
    SHORT = "SHORT"
    FLAT = "FLAT"


@dataclass
class TradeSignal:
    """Represents a trade signal generated by the strategy."""
    signal: Signal
    entry_price: float
    stop_loss: float
    take_profit: float
    strategy: str
    reason: str
    confidence: float  # 0-1
    atr: float
    position_size: int = 1
    timestamp: str = ""


def compute_indicators(df: pd.DataFrame, config) -> pd.DataFrame:
    """
    Compute all technical indicators needed by both hybrid strategies.
    Expects OHLCV DataFrame with columns: open, high, low, close, volume.
    """
    df = df.copy()
    
    # ─── EMAs (QuantVue-inspired) ───
    df["ema_fast"] = df["close"].ewm(span=config.fast_ema_period, adjust=False).mean()
    df["ema_slow"] = df["close"].ewm(span=config.slow_ema_period, adjust=False).mean()
    df["ema_trend"] = df["close"].ewm(span=config.trend_ema_period, adjust=False).mean()
    
    # EMA crossover signals
    df["ema_cross_up"] = (df["ema_fast"] > df["ema_slow"]) & (df["ema_fast"].shift(1) <= df["ema_slow"].shift(1))
    df["ema_cross_down"] = (df["ema_fast"] < df["ema_slow"]) & (df["ema_fast"].shift(1) >= df["ema_slow"].shift(1))
    
    # Trend direction from 50 EMA
    df["trend_bullish"] = df["close"] > df["ema_trend"]
    df["trend_bearish"] = df["close"] < df["ema_trend"]
    
    # ─── ATR (Vector Algorithmics-inspired) ───
    high_low = df["high"] - df["low"]
    high_close = (df["high"] - df["close"].shift(1)).abs()
    low_close = (df["low"] - df["close"].shift(1)).abs()
    true_range = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
    df["atr"] = true_range.rolling(window=config.atr_period).mean()
    
    # ATR bands for breakout detection
    df["atr_upper"] = df["close"] + (df["atr"] * config.atr_breakout_multiplier)
    df["atr_lower"] = df["close"] - (df["atr"] * config.atr_breakout_multiplier)
    
    # ATR expansion (volatility increasing)
    df["atr_expanding"] = df["atr"] > df["atr"].shift(1)
    
    # ─── Volume Filter (QuantVue-style) ───
    df["volume_sma"] = df["volume"].rolling(window=config.volume_sma_period).mean()
    df["volume_confirmed"] = df["volume"] > (df["volume_sma"] * config.volume_multiplier)
    
    # ─── RSI (supplementary) ───
    delta = df["close"].diff()
    gain = delta.where(delta > 0, 0).rolling(window=14).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
    rs = gain / loss.replace(0, np.nan)
    df["rsi"] = 100 - (100 / (1 + rs))
    
    # ─── Bollinger Bands (supplementary) ───
    df["bb_mid"] = df["close"].rolling(window=20).mean()
    bb_std = df["close"].rolling(window=20).std()
    df["bb_upper"] = df["bb_mid"] + (2 * bb_std)
    df["bb_lower"] = df["bb_mid"] - (2 * bb_std)
    
    # ─── VWAP (intraday anchor) ───
    df["cum_vol"] = df["volume"].cumsum()
    df["cum_vol_price"] = (df["close"] * df["volume"]).cumsum()
    df["vwap"] = df["cum_vol_price"] / df["cum_vol"].replace(0, np.nan)
    
    # ─── Pullback detection ───
    # Price touching or crossing fast EMA in trend direction
    df["pullback_to_ema"] = (
        (df["low"] <= df["ema_fast"]) & (df["close"] > df["ema_fast"])  # Bullish pullback
    ) | (
        (df["high"] >= df["ema_fast"]) & (df["close"] < df["ema_fast"])  # Bearish pullback
    )
    
    return df


def compute_opening_range(df: pd.DataFrame, orb_minutes: int = 15) -> Tuple[Optional[float], Optional[float]]:
    """
    Compute the Opening Range (high/low) from the first N minutes of RTH data.
    Assumes df is already filtered to today's RTH session.
    """
    if len(df) < 2:
        return None, None
    
    # Take first orb_minutes / 5 bars (for 5-minute timeframe)
    orb_bars = max(1, orb_minutes // 5)
    orb_data = df.head(orb_bars)
    
    orb_high = orb_data["high"].max()
    orb_low = orb_data["low"].min()
    
    return orb_high, orb_low


def generate_signal_hybrid1(df: pd.DataFrame, config, idx: int = -1) -> Optional[TradeSignal]:
    """
    Hybrid 1: Momentum-Volatility Fusion
    
    LONG conditions:
    1. 9 EMA crosses above 21 EMA (momentum)
    2. Price above 50 EMA (trend filter)
    3. Volume above 1.2× 20-period SMA (confirmation)
    4. ATR expanding (Vector volatility filter)
    
    SHORT conditions: Mirror of above.
    
    Stops: ATR-based (Vector) or fixed points (fallback).
    Targets: R:R ratio × stop distance.
    """
    if len(df) < config.trend_ema_period + 5:
        return None
    
    row = df.iloc[idx]
    prev = df.iloc[idx - 1] if abs(idx) < len(df) else None
    
    if prev is None or pd.isna(row.get("atr")):
        return None
    
    atr = row["atr"]
    close = row["close"]
    
    # Calculate stop distance
    if config.use_atr_stops:
        stop_distance = atr * config.atr_stop_multiplier
    else:
        stop_distance = config.stop_loss_points
    
    # Ensure minimum stop
    stop_distance = max(stop_distance, 10.0)
    
    # ─── LONG Signal ───
    if (row.get("ema_cross_up", False) and 
        row.get("trend_bullish", False) and 
        row.get("volume_confirmed", False)):
        
        # ATR expansion adds confidence
        confidence = 0.6
        if row.get("atr_expanding", False):
            confidence += 0.15
        if row.get("rsi", 50) < 70:  # Not overbought
            confidence += 0.1
        if close > row.get("vwap", close):  # Above VWAP
            confidence += 0.1
        
        # Blend bias: higher confidence if trend-leaning
        confidence *= (0.5 + config.trend_vs_scalp_bias * 0.5)
        confidence = min(confidence, 0.95)
        
        entry = close
        stop = entry - stop_distance
        target = entry + (stop_distance * config.reward_risk_ratio)
        
        return TradeSignal(
            signal=Signal.LONG,
            entry_price=round(entry, 2),
            stop_loss=round(stop, 2),
            take_profit=round(target, 2),
            strategy="hybrid1",
            reason=f"EMA 9/21 bullish cross | Trend ✓ | Vol ✓ | ATR={atr:.1f}",
            confidence=round(confidence, 2),
            atr=round(atr, 2),
        )
    
    # ─── SHORT Signal ───
    if (row.get("ema_cross_down", False) and 
        row.get("trend_bearish", False) and 
        row.get("volume_confirmed", False)):
        
        confidence = 0.6
        if row.get("atr_expanding", False):
            confidence += 0.15
        if row.get("rsi", 50) > 30:  # Not oversold
            confidence += 0.1
        if close < row.get("vwap", close):  # Below VWAP
            confidence += 0.1
        
        confidence *= (0.5 + config.trend_vs_scalp_bias * 0.5)
        confidence = min(confidence, 0.95)
        
        entry = close
        stop = entry + stop_distance
        target = entry - (stop_distance * config.reward_risk_ratio)
        
        return TradeSignal(
            signal=Signal.SHORT,
            entry_price=round(entry, 2),
            stop_loss=round(stop, 2),
            take_profit=round(target, 2),
            strategy="hybrid1",
            reason=f"EMA 9/21 bearish cross | Trend ✓ | Vol ✓ | ATR={atr:.1f}",
            confidence=round(confidence, 2),
            atr=round(atr, 2),
        )
    
    return None


def generate_signal_hybrid2(df: pd.DataFrame, config, 
                            orb_high: Optional[float] = None, 
                            orb_low: Optional[float] = None,
                            idx: int = -1) -> Optional[TradeSignal]:
    """
    Hybrid 2: 5m MNQ ORB/Pullback
    
    LONG conditions (ORB breakout):
    1. Price breaks above opening range high
    2. Price above 50 EMA (trend confirmation)
    3. ATR filter confirms volatility (optional)
    
    LONG conditions (EMA pullback):
    1. Pullback to 9 EMA in bullish trend
    2. Price above 50 EMA
    3. Bounce confirmed (close above fast EMA)
    
    Fixed stops: 20-30 points. Targets: 1.5-2R.
    """
    if len(df) < config.trend_ema_period + 5:
        return None
    
    row = df.iloc[idx]
    prev = df.iloc[idx - 1] if abs(idx) < len(df) else None
    
    if prev is None or pd.isna(row.get("atr")):
        return None
    
    atr = row["atr"]
    close = row["close"]
    high = row["high"]
    low = row["low"]
    stop_distance = config.stop_loss_points  # Fixed stops for Hybrid 2
    
    # ─── ORB Breakout LONG ───
    if orb_high is not None and orb_low is not None:
        if (close > orb_high and 
            row.get("trend_bullish", False) and
            prev["close"] <= orb_high):
            
            confidence = 0.65
            if row.get("atr_expanding", False) and config.orb_atr_filter:
                confidence += 0.15
            if row.get("volume_confirmed", False):
                confidence += 0.1
            
            entry = close
            stop = max(entry - stop_distance, orb_low)
            actual_stop_dist = entry - stop
            target = entry + (actual_stop_dist * config.reward_risk_ratio)
            
            return TradeSignal(
                signal=Signal.LONG,
                entry_price=round(entry, 2),
                stop_loss=round(stop, 2),
                take_profit=round(target, 2),
                strategy="hybrid2",
                reason=f"ORB breakout LONG | High={orb_high:.2f} | ATR={atr:.1f}",
                confidence=round(confidence, 2),
                atr=round(atr, 2),
            )
        
        # ─── ORB Breakout SHORT ───
        if (close < orb_low and 
            row.get("trend_bearish", False) and
            prev["close"] >= orb_low):
            
            confidence = 0.65
            if row.get("atr_expanding", False) and config.orb_atr_filter:
                confidence += 0.15
            if row.get("volume_confirmed", False):
                confidence += 0.1
            
            entry = close
            stop = min(entry + stop_distance, orb_high)
            actual_stop_dist = stop - entry
            target = entry - (actual_stop_dist * config.reward_risk_ratio)
            
            return TradeSignal(
                signal=Signal.SHORT,
                entry_price=round(entry, 2),
                stop_loss=round(stop, 2),
                take_profit=round(target, 2),
                strategy="hybrid2",
                reason=f"ORB breakout SHORT | Low={orb_low:.2f} | ATR={atr:.1f}",
                confidence=round(confidence, 2),
                atr=round(atr, 2),
            )
    
    # ─── EMA Pullback LONG ───
    if (row.get("pullback_to_ema", False) and
        row.get("trend_bullish", False) and
        close > row.get("ema_fast", 0)):
        
        confidence = 0.55
        if row.get("volume_confirmed", False):
            confidence += 0.1
        if row.get("rsi", 50) > 40 and row.get("rsi", 50) < 65:
            confidence += 0.1
        
        entry = close
        stop = entry - stop_distance
        target = entry + (stop_distance * config.reward_risk_ratio)
        
        return TradeSignal(
            signal=Signal.LONG,
            entry_price=round(entry, 2),
            stop_loss=round(stop, 2),
            take_profit=round(target, 2),
            strategy="hybrid2",
            reason=f"EMA pullback LONG | Trend ✓ | ATR={atr:.1f}",
            confidence=round(confidence, 2),
            atr=round(atr, 2),
        )
    
    # ─── EMA Pullback SHORT ───
    if (row.get("pullback_to_ema", False) and
        row.get("trend_bearish", False) and
        close < row.get("ema_fast", float("inf"))):
        
        confidence = 0.55
        if row.get("volume_confirmed", False):
            confidence += 0.1
        if row.get("rsi", 50) > 35 and row.get("rsi", 50) < 60:
            confidence += 0.1
        
        entry = close
        stop = entry + stop_distance
        target = entry - (stop_distance * config.reward_risk_ratio)
        
        return TradeSignal(
            signal=Signal.SHORT,
            entry_price=round(entry, 2),
            stop_loss=round(stop, 2),
            take_profit=round(target, 2),
            strategy="hybrid2",
            reason=f"EMA pullback SHORT | Trend ✓ | ATR={atr:.1f}",
            confidence=round(confidence, 2),
            atr=round(atr, 2),
        )
    
    return None


def run_strategy(df: pd.DataFrame, config, 
                 orb_high: Optional[float] = None,
                 orb_low: Optional[float] = None) -> Optional[TradeSignal]:
    """
    Main strategy dispatcher — runs the configured hybrid strategy.
    """
    df_ind = compute_indicators(df, config)
    
    if config.strategy_mode == "hybrid1":
        return generate_signal_hybrid1(df_ind, config)
    elif config.strategy_mode == "hybrid2":
        return generate_signal_hybrid2(df_ind, config, orb_high, orb_low)
    else:
        # Try both, take highest confidence
        sig1 = generate_signal_hybrid1(df_ind, config)
        sig2 = generate_signal_hybrid2(df_ind, config, orb_high, orb_low)
        
        if sig1 and sig2:
            return sig1 if sig1.confidence >= sig2.confidence else sig2
        return sig1 or sig2
